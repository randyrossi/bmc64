
// p4fliconv: high resolution interlaced FLI converter utility
// Copyright (C) 2007-2008 Istvan Varga <istvanv@users.sourceforge.net>
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
// The Plus/4 program files generated by this utility are not covered by the
// GNU General Public License, and can be used, modified, and distributed
// without any restrictions.

#ifndef P4FLICONV_PRGDATA_HPP
#define P4FLICONV_PRGDATA_HPP

#include "plus4emu.hpp"

namespace Plus4FLIConv {

  class PRGData {
   public:
    static const unsigned char prgHeader_FLI[0x0801];
    static const unsigned char prgHeader_320x200[0x00C1];   // hires Botticelli
    static const unsigned char prgHeader_160x200[0x00C1];   // Multi Botticelli
    static const unsigned char prgHeader_128x64[0x012B];    // Logo Editor V2.0
   private:
    unsigned char   *buf;
    int     *luminanceCodeTable;
    int     *colorCodeTable;
    bool    *bitmapTable;
    int     nLines;
    int     conversionType;
    bool    interlaceEnabled;
   public:
    PRGData();
    virtual ~PRGData();
    void clear();
    // make the use of attribute values more consistent for easier
    // editing of the output file and better compression (should be
    // called before convertImageData())
    void optimizeAttributes();
    void convertImageData();
    void setVerticalSize(int n);
    int getVerticalSize() const;
    /*!
     * Set the conversion type. 'n' can be one of the following values:
     *   0: interlaced high resolution FLI
     *   1: interlaced multicolor FLI
     *   2: high resolution FLI, bitmap interlace only
     *   3: multicolor FLI, bitmap interlace only
     *   4: non-interlaced high resolution FLI
     *   5: non-interlaced multicolor FLI
     *   6: simple 320x200 high resolution mode without FLI
     *   7: simple 160x200 multicolor mode without FLI
     *   8: Logo Editor V2.0 multicolor character bank (128x64)
     */
    void setConversionType(int n);
    int getConversionType() const;
    unsigned int getViewerCodeEndAddress() const;
    unsigned int getImageDataStartAddress() const;
    unsigned int getImageDataEndAddress() const;
    inline unsigned char& operator[](long n)
    {
      return buf[n];
    }
    inline unsigned char& lineBlankFXEnabled()
    {
      return buf[0x0FFCL];
    }
    inline unsigned char& borderColor()
    {
      return buf[(conversionType < 6 ? 0x0FFDL : 0x6BFAL)];
    }
    inline unsigned char& interlaceFlags()
    {
      return buf[0x0FFEL];
    }
    inline unsigned char& lineXShift(long yc)
    {
      return buf[(((yc & 1L) << 10) | 0x0900L | (yc >> 1)) + 1L];
    }
    inline unsigned char& lineColor0(long yc)
    {
      return buf[(((yc & 1L) << 10) | 0x0A00L | (yc >> 1)) + 1L];
    }
    inline unsigned char& lineColor3(long yc)
    {
      return buf[(((yc & 1L) << 10) | 0x0B00L | (yc >> 1)) + 1L];
    }
    inline bool getPixel(long xc, long yc) const
    {
      return bitmapTable[(yc * 320L) + xc];
    }
    inline void setPixel(long xc, long yc, bool n)
    {
      bitmapTable[(yc * 320L) + xc] = n;
    }
    inline int& l0(long xc, long yc)
    {
      return luminanceCodeTable[((yc & (~(long(2)))) * 40L) + (xc >> 3)];
    }
    inline int& l1(long xc, long yc)
    {
      return luminanceCodeTable[((yc | 2L) * 40L) + (xc >> 3)];
    }
    inline int& c0(long xc, long yc)
    {
      return colorCodeTable[((yc & (~(long(2)))) * 40L) + (xc >> 3)];
    }
    inline int& c1(long xc, long yc)
    {
      return colorCodeTable[((yc | 2L) * 40L) + (xc >> 3)];
    }
  };

}       // namespace Plus4FLIConv

#endif  // P4FLICONV_PRGDATA_HPP

